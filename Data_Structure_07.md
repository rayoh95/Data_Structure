### 자료구조.알고리즘

<hr>



### `트리`

* 한 노드가 여러 노드를 가르킬 수 있는 비선형적 자료구조
* 그래프라는 자료구조의 일종
* `데이터 구조의 계층적인 속성(상하관계)`을 표현한다.

`노드` : 트리를 구성하는 각 데이터 원소들

`루트(root)`: 트리의 시작점. 최상위 노드. 트리는 최대 한 개의 루트 노드를 갖을 수 있다.

`엣지(edge)`: 노드들을 연결하는 노드 간선

`부모 노드`

`자식 노드`

`차수(degree)` : 자식 노드의 개수

`리프(leaf).터미널(terminal) 노드` : 자식 노드가 없는 노드. 데이터의 끝 부분.

`깊이(depth)` : 루트 노드로부터의 거리. 트리의 높이 -> level n 이라고도 부른다.

트리는 재귀적인 구조를 갖고 있다. (하나의 트리는 여러개의 서브트리로 나눌 수 있다.)



### `트리의 종류`

* 이진 트리
* AVL 트리, 레드-블랙 트리
* B-트리, B+트리
* 세그먼트 트리
* 트라이





### `1. 이진 트리`

* 각 노드가 최대 2개 (0 ~ 2) 의 자식 노드를 갖는 트리이다.
  * 왼쪽 자식노드 / 오른쪽 자식노드



* `정 이진 트리 (full binary tree), 엄격한(strict) 이진 트리`
  * 모든 노드가 2개의 자식을 갖거나 자식이 없는 트리

* `포화 이진 트리 Perfect Binary Tree` ( 정 이진 트리의 종류 중 하나 )

  * 모든 노드가 2개의 자식을 갖고 leaf 노드가 같은 레벨일 때

  * 높이가 h 인 포화 이진 트리에서 노드 갯수는 `2^(k+1) - 1`

  * Leaf 노드의 갯수는 `2^h`

* `완전 이진 트리 Complete Binary Tree` ( 정 이진 트리의 종류 중 하나 )

  	* 마지막 레벨을 제외하고 모든 노드가 채워져야 한다.
  	
  	* 노드는 왼쪽에서 오른쪽으로 채워진다.



#### 이진 트리는 선형 자료구조인 일차원 배열로도 표현이 가능하다는 특징이 있다.

ex) { -, 1, 2, 3, 4, null, 6 }

* 첫 번째 인덱스 (0번) 은 비워두고 인덱스 번호 1번부터 데이터를 채워간다. -> 1번 부터 루트 값을 넣어야지 인덱스 위치로 데이터를 찾을 수 있는 연산이 존재.
  * 루트 노드 = 1
  * 노드 i 의 부모 = i / 2
  * 노드 i 의 왼쪽 자식 = i * 2
  * 노드 i 의 오른쪽 자식 = i * 2 + 1

`장점`

* 간단하게 트리를 표현할 수 있다.

`단점`

* 배열의 한계(공간의 제약, 데이터의 삽입.삭제)를 극복할 수 없다.



`이진 트리의 노드는 배열처럼 next, pre 가 아닌 left, right 노드로 표현한다.`

```java
class Node {
  int data;
  Node left;
  Node right;
}
```



### 이진 트리의 응용

* 힙
* 이진 탐색 트리 (Binary Search Tree - BST)
* B-tree
* AVL 트리



### 이진 트리의 기본 연산

* 트리에 데이터 삽입
* 데이터 삭제
* 데이터 검색
* `트리 탐색`



### 트리 순회

* 트리 구조에서 각 노드를 `한 번씩` 방문하는 과정

1. ##### `전위 탐색 preorder`

2. ##### `중위 탐색 inorder`

3. ##### `후위 탐색 postorder`



#### `Preorder`

* (루트) 노드를 가장 먼저 방문
* 왼쪽 서브 트리를 preorder 한다.
* 오른쪽 서브 트리를 preorder 한다.

preorder 한다는 의미는 재귀호출로 탐색이 이뤄진다는 뜻 이다. 트리의 특성이 하위 노드는 서브 트리를 구성하는 재귀적 형태이기 때문.



#### `Inorder`

* 왼쪽 서브 트리를 inorder 한다.
* (루트) 노드를 방문한다.
* 오른쪽 서브 트리를 inorder 한다.

inorder 한다는 의미 역시 재귀적 탐색.



#### `Postorder`

* 왼쪽 서브 트리를 postorder 한다.
* 오른쪽 서브 트리를 postorder 한다.
* (루트) 노드를 방문한다.

서브 트리 탐색을 완료한 후에 (루트) 노드를 방문한다. 그래서 후위 탐색





### `이진 탐색 트리 BST`

* 트리 구조 자체로는 데이터의 특성에 아무런 제약이 없다. -> 이 상황에서는 어떤 특정 값을 찾기 위해서는 트리의 모든 데이터를 탐색해야하며, 시간 복잡도에서 아무런 이점이 없다.
* 이진 탐색 트리는 데이터의 특성에 제약을 줌으로서 탐색 속도를 `O(logN)` 으로 줄여준다.

기본적으로 왼쪽 자식 노드와 오른쪽 자식 노드를 갖을 수 있는 이진 트리의 구조이다. 단, 데이터 값에 제약이 생긴다. 제약이란

1. 노드의 왼쪽 서브 트리에는 루트 노드보다 작은 값이 위치
2. 노드의 오른쪽 서브 트리에는 루트 노드보다 큰 값이 위치
3. 서브 트리에는 다시 이진 탐색 트리로 구성한다.
4. 중복된 값은 없다.

트리의 최소값은 깊이(레벨)과 상관 없이 가장 왼쪽에 위치한다. 트리의 최대값 역시 깊이(레벨)과 상관 없이 가장 오른쪽에 위치한다.



##### 때문에 이진 탐색 트리를 `중위 탐색`을 할 경우 정렬된 데이터를 가져올 수 있다.



데이터의 삽입 

* 중복된 데이터는 삽입하지 않고
* 추가된 노드는 루트 노드로부터 값을 비교해가며 트리의 leaf 에 삽입한다.

데이터의 삭제

* 삭제 데이터의 위치를 찾는다.
* 삭제할 데이터가 leaf 인 경우
  * null 을 부모 노드에게 return 시켜 자신을 가리키던 자식 포인터를 null 값으로 바꾼다.
* 한 개의 자식 노드를 가질 경우
  * 하나 있는 자식 노드를 부모 노드로 보내면 된다.
* 두 개의 자식 노드를 가질 경우 ( 두 가지 방법이 존재 )
  1. 왼쪽 서브 트리의 최댓값과 교체
  2. 오른쪽 서브 트리의 최솟값과 교체

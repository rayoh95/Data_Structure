### 자료구조.알고리즘



자료(데이터) 를 어디에 어떻게 관리(검색, 순회, 저장, 삭제, 변경...)할지. `자료를 담는 추상적인 틀`(Data Structure)

* 한정적인 자원 내에서 정확한 결과를 내야한다.
* 데이터의 형태와 쓰임에 가장 적합한 자료구조를 쓰는 것이 개발에서 매우 중요.
* `최적화`를 위한 작업

알고리즘은 주어진 문제를 풀기 위한 동작들의 절차. `Input 값`을 통해 `Output 결과`를 내는 `과정`



#### 점근 표기법

**점근 표기법(asymptotic notation)**은 어떤 함수의 증가 양상을 다른 함수와의 비교로 표현하는 수론과 해석학의 방법이다. **알고리즘의 복잡도를 단순화할 때**나 무한급수의 뒷부분을 간소화할 때 쓰인다.

* ##### `빅오(Big-O)` 표기법

* 세타 표기법
* 오메가 표기법



#### Big-O

예를 들어 N개의 공간에 데이터가 순차적으로 들어있다. 한 공간의 데이터를 조회하는데 걸리는 시간을 t초라고 가정하자. 7개의 공간 중 원하는 데이터를 찾는데 걸리는 시간은 몇 초 라고 말할 수 있을까? 맨 앞에 데이터가 존재한다면 t초가 걸릴 것 이고, 맨 뒤에 데이터가 존재한다면 N*t초가 걸릴 것 이다. n초는 하한, N*t초는 상한이다. 그럼 데이터를 찾는데 걸리는 시간은 t초일까 N*t초일까 아님 두 경우의 중간값인 평균값일까. `빅오 표기법`은 가장 `상한`인 경우를 가정하여 `복잡도를 표기`한다.

*  정확한 시간을 알려주는 것이 아닌 어떤 경우라도 그 범주에 속한다는 의미



##### 점근 표기법의 특징

* 가장 큰 영향력이 있는 항만 표시
  * O(N^3 + N^2 + N) -> O(N^3)
* 상수항은 무시
  * O(2N + 1) -> O(N)



##### 공간 복잡도

* 데이터 관리에 필요한 공간
* 데이터의 양의 변화에 다라 공간의 변화
* 예상 소요 공간 측정



##### `시간 복잡도`

* 데이터 처리에 소요되는 시간
* 데이터 양의 변화에 따른 소요 시간의 변화
* 예상 처리 시간을 측정
  * 수 만개 혹은 수 억개의 데이터를 처리해야 한다면..?
* 지연 장애가 발생했을 때 왜 발생했는지를 찾을 수 있는 근거



1. ##### O(1)

* 입력 데이터의 크기와 상관없이 항상 일정한 시간이 걸리는 알고리즘
  * 배열의 `Random Access`
  * `Hash`

2. ##### O(N)

* 입력 데이터의 크기에 비례해서 시간이 소요되는 알고리즘

  * ```java
    for (int i = 0; i < N; i++) {
      //
    }
    ```

3. ##### O(N^2)

* 입력 데이터의 제곱에 비례해서 시간이 소요되는 알고리즘

  * ```java
    for (int i = 0; i < N; i++) {
      for (int j = 0; j < N; j++) {
        //
      }
    }
    ```

4. #### O(logN)

* `이짐탐색 (Binary search)`

  * 예를 들어 1 부터 100 까지의 숫자가 있을 때 특정 숫자를 찾는 가장 효율적인 알고리즘. -> 숫자를 절반씩 줄여나가면서 크기를 비교한다.

  * 한 번의 순회로 데이터를 절반씩 줄여나가는 것이 특징

  * ![img](https://t1.daumcdn.net/cfile/tistory/23546A4851A1DE8B11)

    ![img](https://t1.daumcdn.net/cfile/tistory/22232C4951A1E02811)

  * K 번 탐색할 때 log(n) 의 시간 복잡도를 갖는다.

5. ##### O(NlogN)

* `Merge sort`
  * 주어진 데이터를 절반씩 계속 나눈다 -> logN 의 시간 복잡도를 갖는다.
  * 나눈 후 하나씩 값을 비교해가면서 값을 정렬한다. 데이터의 개수인 N 번 만큼 과정을 거친다 -> NlogN



